<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bubbles!</title>
    <link rel="stylesheet" href="center.css" />
</head>
<body>
    <div class="container" id="container">
    </div>
    <script src="../common/d3.js"></script>
    <script src="../common/jquery-1.11.3.min.js"></script>
    <script>

        var url = 'gc.jpg';
        var url = 'http://www.chinesemedicineliving.com/blog/wp-content/uploads/2015/05/watermelon.jpg';
//        var url = 'http://cdn1.medicalnewstoday.com/content/images/articles/266/266886/watermelon.jpg';

        var cross_origin = true;
        if (cross_origin) {
            url = 'http://crossorigin.me/' + url;
        }

        $(document).ready(loadImage(url));

        function loadImage(url) {
            // Create an offscreen canvas
            var canvas = $('<canvas/>')[0];
            var context = canvas.getContext('2d');

            // Setup image
            var img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                context.drawImage(img, 0, 0, img.width, img.height);
                // Start drawing circles
                var tick = circleSetup(img, context);
                setInterval(tick, 50);
            };

            // Load image
            img.src = url;
        }

        function getAverageRGB(img, context) {

            var blockSize = 5, // only visit every 5 pixels
                defaultRGB = {r:0,g:0,b:0}, // for non-supporting envs
                data, width, height,
                i = -4,
                length,
                rgb = {r:0,g:0,b:0},
                count = 0;

            if (!context) {
                return defaultRGB;
            }

            data = context.getImageData(0, 0, img.width, img.height);

            length = data.data.length;

            while ( (i += blockSize * 4) < length ) {
                ++count;
                rgb.r += data.data[i];
                rgb.g += data.data[i+1];
                rgb.b += data.data[i+2];
            }

            // ~~ used to floor values
            rgb.r = ~~(rgb.r/count);
            rgb.g = ~~(rgb.g/count);
            rgb.b = ~~(rgb.b/count);

            return rgb;

        }

        function circleSetup (img, context) {
            var maxRadius = img.width / 100, // maximum radius of circle
                padding = 1, // padding between circles; also minimum radius
                margin = {top: 0, right: 0, bottom: 0, left: 0},
                width = img.width - margin.left - margin.right,
                height = img.height - margin.top - margin.bottom;

            var k = 5, // initial number of candidates to consider per circle
                m = 5, // initial number of circles to add per frame
                n = 10000, // remaining number of circles to add
                newCircle = bestCircleGenerator(maxRadius, padding);

            var svg = d3.select("#container").append("svg")
                    .attr("width", img.width)
                    .attr("height", img.height);

            var rgb = getAverageRGB(img, context);

            document.body.style.backgroundColor =  "rgb(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ")";

            function tick() {
              for (var i = 0; i < m && --n >= 0; ++i) {

                  var circle = newCircle(k);

                  var rgba = context.getImageData(circle[0], circle[1], 1, 1).data;

                  svg.append("circle")
                          .attr("cx", circle[0])
                          .attr("cy", circle[1])
                    .attr("r", 0)
                                .attr("fill", "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")")
                    .style("fill-opacity", 1)
                      .transition()
                    .attr("r", circle[2])
                    .duration(10000);

                // As we add more circles, generate more candidates per circle.
                // Since this takes more effort, gradually reduce circles per frame.
                if (k < 500) k *= 1.01, m *= .998;
              }
              return !n;
            };

            //d3.timer(tick);
            //setInterval(tick, 50);

            function bestCircleGenerator(maxRadius, padding) {
              var quadtree = d3.geom.quadtree().extent([[0, 0], [width, height]])([]),
                  searchRadius = maxRadius * 2,
                  maxRadius2 = maxRadius * maxRadius;

              return function(k) {
                var bestX, bestY, bestDistance = 0;

                for (var i = 0; i < k || bestDistance < padding; ++i) {
                  var x = Math.random() * width,
                      y = Math.random() * height,
                      rx1 = x - searchRadius,
                      rx2 = x + searchRadius,
                      ry1 = y - searchRadius,
                      ry2 = y + searchRadius,
                      minDistance = maxRadius; // minimum distance for this candidate

                  quadtree.visit(function(quad, x1, y1, x2, y2) {
                    if (p = quad.point) {
                      var p,
                          dx = x - p[0],
                          dy = y - p[1],
                          d2 = dx * dx + dy * dy,
                          r2 = p[2] * p[2];
                      if (d2 < r2) return minDistance = 0, true; // within a circle
                      var d = Math.sqrt(d2) - p[2];
                      if (d < minDistance) minDistance = d;
                    }
                    return !minDistance || x1 > rx2 || x2 < rx1 || y1 > ry2 || y2 < ry1; // or outside search radius
                  });

                  if (minDistance > bestDistance) bestX = x, bestY = y, bestDistance = minDistance;
                }

                var best = [bestX, bestY, bestDistance - padding];
                quadtree.add(best);
                return best;
              };
            }
            return tick;
        }

    </script>
</body>
</html>